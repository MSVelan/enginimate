name: Render Manim animation and upload to cloudinary

on:
  repository_dispatch:
    types: [render-manim]

jobs:
  render:
    runs-on: ubuntu-latest
    environment: Render-Manim-Videos

    steps:
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.13"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            python3-dev \
            libcairo2-dev \
            libpango1.0-dev \
            dvisvgm \
            ffmpeg \
            texlive \
            texlive-latex-recommended \
            texlive-latex-extra \
            texlive-pictures \
            texlive-fonts-extra \
            texlive-science \
            tipa \

      - name: Install Manim
        run: |
          pip install manim cloudinary httpx numpy

      - name: Create Manim script
        run: |
          cat > scene.py << 'EOFSCRIPT'
          from manim import *

          ${{ github.event.client_payload.code }}
          EOFSCRIPT

      - name: Render animation
        id: render
        run: |
          SCENE_NAME="${{ github.event.client_payload.scene_name || 'Enginimate' }}"
          QUALITY="${{ github.event.client_payload.quality || 'high' }}"

          case $QUALITY in
            low)
              QUALITY_FLAG="-ql"
              ;;
            high)
              QUALITY_FLAG="-qh"
              ;;
            *)
              QUALITY_FLAG="-qm"
              ;;
          esac

          manim scene.py $SCENE_NAME $QUALITY_FLAG

          # Find the generated video
          VIDEO_FILE=$(find media/videos -name "*.mp4" | head -n 1)
          echo "video_file=$VIDEO_FILE" >> $GITHUB_OUTPUT
          echo "Generated video: $VIDEO_FILE"

      - name: Upload to Cloudinary
        id: upload
        env:
          CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}
        run: |
          python << 'EOFPYTHON'
          import os
          import cloudinary
          import cloudinary.uploader

          # Configure Cloudinary
          cloudinary.config(
              cloud_name=os.environ['CLOUDINARY_CLOUD_NAME'],
              api_key=os.environ['CLOUDINARY_API_KEY'],
              api_secret=os.environ['CLOUDINARY_API_SECRET'],
              secure=True
          )

          video_file = "${{ steps.render.outputs.video_file }}"

          try:
              print(f"Uploading video: {video_file}")
              
              if not os.path.exists(video_file):
                  raise Exception(f"Video file not found: {video_file}")
              
              result = cloudinary.uploader.upload_large(
                  video_file,
                  resource_type="video",
                  folder="manim-renders",
                  use_filename=True,
                  unique_filename=True
              )
              
              video_url = result['secure_url']
              
              print(f"Video uploaded successfully!")
              print(f"URL: {video_url}")
              print(f"Public ID: {result.get('public_id')}")
              
              # Save to GitHub output
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"url={video_url}\n")
                  f.write(f"public_id={result.get('public_id')}\n")
                  
          except Exception as e:
              print(f"Error uploading video: {repr(e)}")
              raise
          EOFPYTHON

      - name: Send webhook with results
        if: github.event_name == 'repository_dispatch'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          python << 'EOFPYTHON'
          import os
          import json
          import httpx
          import hmac
          import hashlib

          video_url = "${{ steps.upload.outputs.url }}"
          public_id = "${{ steps.upload.outputs.public_id }}"
          uuid = "${{ github.event.client_payload.uuid }}"
          webhook_url = os.getenv("WEBHOOK_URL")
          webhook_secret = os.getenv("WEBHOOK_SECRET", "")

          if not webhook_url:
              print("No webhook URL configured. Skipping webhook.")
              exit(0)

          payload = {
              "uuid": uuid,
              "video_url": video_url,
              "public_id": public_id,
              "status": "completed",
              "run_id": "${{ github.run_id }}"
          }

          print(f"Sending webhook to: {webhook_url}")
          print(f"Payload: {json.dumps(payload, indent=2)}")

          # Create signature
          payload_json = json.dumps(payload, separators=(',', ':'), sort_keys=True)
          payload_bytes = payload_json.encode('utf-8')
          signature = "sha256=" + hmac.new(
              webhook_secret.encode(),
              payload_bytes,
              hashlib.sha256
          ).hexdigest()

          try:
              client = httpx.Client(timeout=30.0)
              response = client.post(
                  webhook_url,
                  content=payload_bytes,
                  headers={
                      "Content-Type": "application/json",
                      "X-Hub-Signature-256": signature
                  }
              )
              print(f"Webhook response status: {response.status_code}")
              print(f"Webhook response: {response.text}")
          except Exception as e:
              print(f"Error sending webhook: {repr(e)}")
              # Don't fail the workflow if webhook fails
          EOFPYTHON

  notify_failure:
    if: failure()
    runs-on: ubuntu-latest
    needs: [render] # Replace with your actual job name
    steps:
      - name: Send failure webhook
        env:
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ERROR_MSG="Workflow failed"

          # Try to get actual error from GitHub API
          RUN_DATA=$(curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs")

          # Extract the conclusion message from failed steps
          FAILED_STEP=$(echo "$RUN_DATA" | jq -r '.jobs[] | select(.name=="render") | .steps[] | select(.conclusion=="failure") | "\(.name): \(.conclusion)"' | head -1)

          if [ ! -z "$FAILED_STEP" ]; then
            ERROR_MSG="Step failed: $FAILED_STEP"
          fi

          # Add job result for more context
          JOB_RESULT="${{ needs.render.result }}"
          ERROR_MSG="$ERROR_MSG (Job status: $JOB_RESULT)"

          # Construct the payload
          PAYLOAD='{"uuid":"'${{ github.event.client_payload.uuid }}'","status":"failed","error":"'"$ERROR_MSG"'","run_id":"'${{ github.run_id }}'"}'
          PAYLOAD=$(echo "$PAYLOAD" | jq -c -S .)

          # Generate HMAC signature
          SIGNATURE="sha256=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | sed 's/^.* //')"

          # Send webhook
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-Hub-Signature-256: $SIGNATURE" \
            -d "$PAYLOAD" \
            -w "\nHTTP Status: %{http_code}\n" \
            || echo "Webhook failed but continuing"
