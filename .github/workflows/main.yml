name: Render Manim animation and upload to cloudinary

on:
  repository_dispatch:
    types: [render-manim]

jobs:
  render:
    runs-on: ubuntu-latest
    environment: Render-Manim-Videos

    steps:
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.13"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            python3-dev \
            libcairo2-dev \
            libpango1.0-dev \
            dvisvgm \
            ffmpeg \
            texlive-full \

      - name: Install Manim
        run: |
          pip install manim cloudinary httpx numpy

      - name: Create Manim script
        run: |
          cat > scene.py << 'EOFSCRIPT'
          from manim import *

          ${{ github.event.client_payload.code }}
          EOFSCRIPT

      - name: Render animation
        id: render
        run: |
          SCENE_NAME="${{ github.event.client_payload.scene_name || 'Enginimate' }}"
          QUALITY="${{ github.event.client_payload.quality || 'high' }}"

          case $QUALITY in
            low)
              QUALITY_FLAG="-ql"
              ;;
            high)
              QUALITY_FLAG="-qh"
              ;;
            *)
              QUALITY_FLAG="-qm"
              ;;
          esac

          manim scene.py $SCENE_NAME $QUALITY_FLAG

          # Find the generated video
          VIDEO_FILE=$(find media/videos -name "*.mp4" | head -n 1)
          echo "video_file=$VIDEO_FILE" >> $GITHUB_OUTPUT
          echo "Generated video: $VIDEO_FILE"

      - name: Upload to Cloudinary
        id: upload
        env:
          CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}
        run: |
          python << 'EOFPYTHON'
          import os
          import cloudinary
          import cloudinary.uploader

          # Configure Cloudinary
          cloudinary.config(
              cloud_name=os.environ['CLOUDINARY_CLOUD_NAME'],
              api_key=os.environ['CLOUDINARY_API_KEY'],
              api_secret=os.environ['CLOUDINARY_API_SECRET'],
              secure=True
          )

          video_file = "${{ steps.render.outputs.video_file }}"

          try:
              print(f"Uploading video: {video_file}")
              
              if not os.path.exists(video_file):
                  raise Exception(f"Video file not found: {video_file}")
              
              result = cloudinary.uploader.upload_large(
                  video_file,
                  resource_type="video",
                  folder="manim-renders",
                  use_filename=True,
                  unique_filename=True
              )
              
              video_url = result['secure_url']
              
              print(f"Video uploaded successfully!")
              print(f"URL: {video_url}")
              print(f"Public ID: {result.get('public_id')}")
              
              # Save to GitHub output
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"url={video_url}\n")
                  f.write(f"public_id={result.get('public_id')}\n")
                  
          except Exception as e:
              print(f"Error uploading video: {repr(e)}")
              raise
          EOFPYTHON

      - name: Send webhook with results
        if: github.event_name == 'repository_dispatch'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
        run: |
          python << 'EOFPYTHON'
          import os
          import json
          import httpx
          import hmac
          import hashlib

          video_url = "${{ steps.upload.outputs.url }}"
          public_id = "${{ steps.upload.outputs.public_id }}"
          uuid = "${{ github.event.client_payload.uuid }}"
          webhook_url = os.getenv("WEBHOOK_URL")
          webhook_secret = os.getenv("WEBHOOK_SECRET", "")

          if not webhook_url:
              print("No webhook URL configured. Skipping webhook.")
              exit(0)

          payload = {
              "uuid": uuid,
              "video_url": video_url,
              "public_id": public_id,
              "status": "completed",
              "run_id": "${{ github.run_id }}"
          }

          print(f"Sending webhook to: {webhook_url}")
          print(f"Payload: {json.dumps(payload, indent=2)}")

          # Create signature
          payload_json = json.dumps(payload, separators=(',', ':'), sort_keys=True)
          payload_bytes = payload_json.encode('utf-8')
          signature = "sha256=" + hmac.new(
              webhook_secret.encode(),
              payload_bytes,
              hashlib.sha256
          ).hexdigest()

          try:
              client = httpx.Client(timeout=30.0)
              response = client.post(
                  webhook_url,
                  content=payload_bytes,
                  headers={
                      "Content-Type": "application/json",
                      "X-Hub-Signature-256": signature
                  }
              )
              print(f"Webhook response status: {response.status_code}")
              print(f"Webhook response: {response.text}")
          except Exception as e:
              print(f"Error sending webhook: {repr(e)}")
              # Don't fail the workflow if webhook fails
          EOFPYTHON
